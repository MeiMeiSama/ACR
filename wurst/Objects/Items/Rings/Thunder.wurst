package Thunder

import ClosureForGroups
import ObjectDefinitions
import ClosureTimers
import GroupUtils
import TerrainUtils
import DummyCaster
import OrderIds
import ACR_Effects
import AbilityGlobals
import DamageEvent
import ACR_TagSystem

init
    thunderDash ()

function trueDash(unit caster, vec2 pos, vec2 spellPos)
    BlzSetUnitFacingEx(caster, pos.angleTo(spellPos).degrees())
    caster.setAnimation(1)
    caster.setInvulnerable(true)
    if caster.hasTagPauseEX() == false
        IssueImmediateOrder(caster, "stop")
        caster.pauseEx()
        caster.addTagPauseEX()

function falseDash(unit caster)
    caster.setInvulnerable(false)    
    if caster.hasTagPauseEX()
        caster.unpauseEx()
        caster.removeTagPauseEX()

function thunderDash ()
    CreateTrigger()
    ..registerAnyUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT)
    ..addAction() ->
        if GetSpellAbilityId() == THUNDER_VONGOLA_ABILITY
            // Variables
            let caster = GetTriggerUnit()
            let castX = GetSpellTargetX()
            let castY = GetSpellTargetY()
            var spellPos = vec2(castX, castY)
            let dmg = ((caster.getStr(true) * 2.5) + 100)
            let damaged = CreateGroup()
            var pos = caster.getPos()
            let eff1 = addEffect("war3mapImported\\a_new_k3.mdx", pos)
            eff1..setYaw(pos.angleTo(spellPos))..setScale(1.5)
            doAfter(3) -> 
                eff1.destr()
            // Code
            caster.setAnimation("spell")
            if pos.distanceTo(spellPos) > 1000 // If cast range is greater than 1500, set it to 1500
                spellPos = pos.polarOffset(pos.angleTo(spellPos), 1000)
            trueDash(caster, pos, spellPos)
            // Loop
            var dashCount = 0
            doPeriodicallyCounted(0.03, 100) (CallbackCounted cb) ->
                dashCount++
                print(dashCount)
                if pos.polarOffset(pos.angleTo(spellPos), 100).isTerrainPathable(PATHING_TYPE_WALKABILITY) == true and pos.polarOffset(pos.angleTo(spellPos), 100).isTerrainPathable(PATHING_TYPE_FLYABILITY) == true// This one is weird, but it works this way: if playable area, and not boundary (black terrain) do 
                    falseDash(caster)
                    damaged.release()
                    destroy cb
                else
                    if pos.distanceTo(spellPos) > 100 // if the distance where he wants to dash to is greater than 100, move him
                        caster.setInvulnerable(true)
                        if caster.hasTagPauseEX() == false
                            caster.pauseEx()
                            caster.addTagPauseEX()
                        caster.setXY(pos.polarOffset(pos.angleTo(spellPos), 100)) // Polar offset moves "position coordinates" a certain distance with given angle
                        pos = caster.getPos()
                        forUnitsInRange(pos, 250) (unit u) -> // Damage units once in range
                            if caster.isEnemyOf(u) and damaged.has(u) == false and u.isInvulnerable() == false
                                DamageEvent.setNextDamageId(DAMAGE_ABILITY_THUNDER_RING)
                                DamageEvent.setNextDamageFromCode()
                                caster.damageTarget(u, dmg, ATTACK_TYPE_MAGIC)
                                damaged.add(u)
                                new DummyCaster()
                                ..owner(caster.getOwner())
                                ..origin(caster.getPos())
                                ..castTarget(THUNDER_VONGOLA_SLOW_DUMMY_SPELL, 1, OrderIds.slow, u)
                                doPeriodicallyCounted(0.05, 14) (CallbackCounted cb) ->
                                    IssueImmediateOrder(u, "stop")
                                    flashEffect(THUNDER_EFFECT, u, "origin")

                    else // if the distance is closer than 100, stop the dash
                        falseDash(caster)
                        damaged.release()
                        destroy cb
                if dashCount == 10
                    falseDash(caster)
                    damaged.release()
                    destroy cb        

        else if GetSpellAbilityId() == THUNDER_ARCO_ABILITY
            // Variables
            let caster = GetTriggerUnit()
            let castX = GetSpellTargetX()
            let castY = GetSpellTargetY()
            var spellPos = vec2(castX, castY)
            let dmg = ((caster.getStr(true) * 4.0) + 200)
            let damaged = CreateGroup()
            var pos = caster.getPos()
            // Code
            let eff2 = addEffect("war3mapImported\\a_new_k3.mdx", pos)
            eff2..setYaw(pos.angleTo(spellPos))..setScale(1.5)
            doAfter(3) -> 
                eff2.destr()
            caster.setAnimation("walk")
            if pos.distanceTo(spellPos) > 1000 // If cast range is greater than 1500, set it to 1500
                spellPos = pos.polarOffset(pos.angleTo(spellPos), 1000)
            trueDash(caster, pos, spellPos)
            // Loop
            var dashCount = 0
            doPeriodicallyCounted(0.03, 100) (CallbackCounted cb) ->
                dashCount++
                if pos.polarOffset(pos.angleTo(spellPos), 100).isTerrainPathable(PATHING_TYPE_WALKABILITY) == true and pos.polarOffset(pos.angleTo(spellPos), 100).isTerrainPathable(PATHING_TYPE_FLYABILITY) == true // This one is weird, but it works this way: if playable area, and not boundary (black terrain) do 
                    falseDash(caster)
                    damaged.release()
                    destroy cb
                else
                    if pos.distanceTo(spellPos) > 100 // if the distance where he wants to dash to is greater than 100, move him
                        caster.setInvulnerable(true)
                        if caster.hasTagPauseEX() == false
                            caster.pauseEx()
                            caster.addTagPauseEX()                        
                        caster.setXY(pos.polarOffset(pos.angleTo(spellPos), 100)) // Polar offset moves "position coordinates" a certain distance with given angle
                        pos = caster.getPos()
                        forUnitsInRange(pos, 250) (unit u) -> // Damage units once in range
                            if caster.isEnemyOf(u) and damaged.has(u) == false and u.isInvulnerable() == false
                                DamageEvent.setNextDamageId(DAMAGE_ABILITY_THUNDER_ARCO)
                                DamageEvent.setNextDamageFromCode()
                                caster.damageTarget(u, dmg, ATTACK_TYPE_MAGIC)
                                damaged.add(u)
                                new DummyCaster()
                                ..owner(caster.getOwner())
                                ..origin(caster.getPos())
                                ..castTarget(THUNDER_ARCO_SLOW_DUMMY_SPELL, 1, OrderIds.slow, u)
                                doPeriodicallyCounted(0.05, 20) (CallbackCounted cb) ->
                                    IssueImmediateOrder(u, "stop")
                                    flashEffect(THUNDER_EFFECT, u, "origin")
                    else // if the distance is closer than 100, stop the dash
                        falseDash(caster)
                        damaged.release()
                        destroy cb
                if dashCount == 10
                    falseDash(caster)
                    damaged.release()
                    destroy cb   